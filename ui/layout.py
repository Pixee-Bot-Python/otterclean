import curses
import os
import textwrap
from ui.details import DetailsDisplay
from ui.components import ProgressBar
from config.settings import MIN_TERMINAL_WIDTH, MIN_TERMINAL_HEIGHT, COLOR_SCHEME

class LayoutManager:
    def __init__(self, stdscr, menu):
        self.stdscr = stdscr
        self.menu = menu
        self.details_display = DetailsDisplay(stdscr)
        self.window_height, self.window_width = self.stdscr.getmaxyx()
        self.menu_width = self.window_width // 3
        self.progress_bar = ProgressBar(stdscr, 100, self.window_height - 2, 0, self.window_width)

    def check_terminal_size(self):
        height, width = self.stdscr.getmaxyx()
        if height < MIN_TERMINAL_HEIGHT or width < MIN_TERMINAL_WIDTH:
            raise curses.error(f"Terminal window too small. Please resize to at least {
                               MIN_TERMINAL_WIDTH}x{MIN_TERMINAL_HEIGHT}.")

    def handle_resize(self):
        curses.update_lines_cols()
        new_height, new_width = self.stdscr.getmaxyx()
        if new_height < MIN_TERMINAL_HEIGHT or new_width < MIN_TERMINAL_WIDTH:
            self.stdscr.clear()
            self.stdscr.addstr(0, 0, f"Window too small. Minimum size: {
                               MIN_TERMINAL_WIDTH}x{MIN_TERMINAL_HEIGHT}")
            self.stdscr.refresh()
            return

        curses.resizeterm(new_height, new_width)
        self.window_height, self.window_width = new_height, new_width
        self.render(self.menu.get_selected_option())
        self.stdscr.refresh()

    def render(self, current_option):
        self.stdscr.clear()
        self.draw_borders()
        self.menu.render()
        details = self.get_details_for_option(current_option)
        self.details_display.render(details)
        self.draw_footer()
        self.stdscr.refresh()

    def draw_borders(self):
        self.stdscr.attron(curses.color_pair(COLOR_SCHEME['default']))

        # Ana pencere kenarları
        self.stdscr.border()

        # Menu bölümü için başlık ve kenar çizgisi
        self.stdscr.addstr(0, 2, " Clean My System ")
        self.stdscr.hline(1, 1, curses.ACS_HLINE, self.menu_width - 2)

        # Details bölümü için başlık ve kenar çizgisi
        self.stdscr.addstr(0, self.menu_width + 2, " Operation Details ")
        self.stdscr.hline(1, self.menu_width + 1, curses.ACS_HLINE, self.window_width - self.menu_width - 2)
        self.stdscr.vline(1, self.menu_width, curses.ACS_VLINE, self.window_height - 3)

        # Footer bölümü için çizgi
        self.stdscr.hline(self.window_height - 3, 1, curses.ACS_HLINE, self.window_width - 2)

        self.stdscr.attroff(curses.color_pair(COLOR_SCHEME['default']))

    def draw_footer(self):
        self.progress_bar.render()
        footer_text = "Press 'q' to quit | Arrow keys to navigate | Enter to select"
        footer_y = self.window_height - 1
        self.stdscr.addstr(footer_y, 1, footer_text[:self.window_width - 2])
        self.stdscr.refresh()


    def get_details_for_option(self, option):
        details_map = {
            0: "Comprehensive Docker Cleanup: Removes all unused containers, networks, images, and volumes.",
            1: "Remove Unused Docker Images: Deletes Docker images that are not associated with any containers.",
            2: "Remove Stopped Containers: Removes Docker containers that are not currently running.",
            3: "Remove Unused Docker Volumes: Deletes Docker volumes that are not associated with any containers.",
            4: "Clean Docker Build Cache: Removes the build cache used by Docker to speed up image builds.",
            5: "Clean Application Cache: Removes temporary files stored by applications to improve performance.",
            6: "Clean User Logs: Deletes log files generated by user applications.",
            7: "Clean System Logs: Removes system-generated log files.",
            8: "Clean System Cache: Clears system-level cache files.",
            9: "Clean All System Caches: Removes all types of system and application caches.",
            10: "Disk Usage Analysis: Provides a detailed breakdown of disk space usage.",
            11: "Clean Selected Application Caches: Allows you to choose specific application caches to clean.",
            12: "Exit: Close the application."
        }

        return details_map.get(option, "No details available for this option.")


    def update_details(self, content):
        max_y, max_x = self.stdscr.getmaxyx()
        detail_width = max_x - self.menu_width - 1
        detail_win = self.stdscr.subwin(
            max_y - 2, detail_width, 1, self.menu_width + 1)
        detail_win.clear()
        detail_win.box()

        lines = content.split('\n')
        for i, line in enumerate(lines):
            if i >= max_y - 4:  # Leave space for borders
                break
            detail_win.addstr(i + 1, 1, line[:detail_width - 2])

        detail_win.refresh()

    def display_app_caches(self, app_caches, current_selection, selected_caches):
        max_y, max_x = self.stdscr.getmaxyx()
        detail_height = max_y - 9  # Leave space for borders, title, and legend
        detail_width = (2 * max_x) // 3 - 3  # Use two-thirds of the screen width for details

        # Calculate the visible range based on current_selection
        start_index = max(0, current_selection - detail_height // 2)
        end_index = min(len(app_caches), start_index + detail_height)

        # Prepare content to fit within the details section
        content = "Select Application Caches to Clean:\n\n"
        for i in range(start_index, end_index):
            path, size = app_caches[i]
            marker = "X" if i in selected_caches else " "
            line = f"[{marker}] {os.path.basename(path)}: {size}"
            if i == current_selection:
                line = "> " + line
            else:
                line = "  " + line
            # Ensure line doesn't exceed the available detail width
            content += line[:detail_width - 2] + "\n"

        # Update the details area with the prepared content
        self.update_details(content)

        # Display scroll indicators if necessary
        if start_index > 0:
            self.stdscr.addch(3, self.menu_width + detail_width, '^')
        if end_index < len(app_caches):
            self.stdscr.addch(max_y - 7, self.menu_width + detail_width, 'v')

        # Add legend horizontally, within the details section
        legend = "↑↓: Move selection   Space: Toggle selection   Enter: Start cleanup   Q: Return to main menu"
        self.stdscr.addstr(max_y - 5, self.menu_width + 2, legend[:detail_width - 2])

        # Refresh to display changes
        self.stdscr.refresh()

    def display_message(self, message):
        """
        Displays a message in the footer area.

        Args:
            message (str): The message to display.
        """
        max_y, max_x = self.stdscr.getmaxyx()
        self.stdscr.addstr(max_y - 1, 0, message[:max_x - 1])
        self.stdscr.clrtoeol()  # Clear the rest of the line
        self.stdscr.refresh()

    def display_result(self, result):
        """
        Displays the result of an operation in the details area.

        Args:
            result (dict or str): The result to display.
        """
        max_y, max_x = self.stdscr.getmaxyx()
        split_point = max_x // 3

        # Clear the details area
        for y in range(3, max_y - 4):
            self.stdscr.addstr(y, split_point + 2, " " * (max_x - split_point - 4))

        if isinstance(result, dict):
            # Display the summary
            summary = f"Operation Summary:\n"
            summary += f"Directories processed: {result.get('total_dirs', 'N/A')}\n"
            summary += f"Directories cleaned: {result.get('cleaned_dirs', 'N/A')}\n"
            summary += f"Errors encountered: {len(result.get('errors', []))}\n\n"

            summary += "Cleaned Directories:\n"
            for dir_path, size in result.get('cleared_sizes', {}).items():
                summary += f"{dir_path}: {size}\n"

            if result.get('errors'):
                summary += "\nErrors encountered (first 5):\n"
                for error in result['errors'][:5]:
                    summary += f"{error}\n"
                if len(result['errors']) > 5:
                    summary += f"... and {len(result['errors']) - 5} more errors."
        else:
            summary = str(result)

        # Display the summary
        lines = summary.split('\n')
        for idx, line in enumerate(lines):
            if 3 + idx < max_y - 4:  # Ensure we don't write beyond the bottom of the screen
                self.stdscr.addstr(3 + idx, split_point + 2, line[:max_x - split_point - 4])

        self.stdscr.refresh()


    def display_operation_result(self, message):
        """
        Displays the operation result in the Operation Details section.

        Args:
            message (str): The message to display.
        """
        max_y, max_x = self.stdscr.getmaxyx()
        detail_start_y = max_y - 5  # Footer'ın üstünde göster
        detail_start_x = 1
        detail_width = max_x - 2

        # Mesajı göster
        wrapped_message = textwrap.wrap(message, detail_width)
        for idx, line in enumerate(wrapped_message):
            if detail_start_y + idx < max_y - 3:
                self.stdscr.addstr(detail_start_y + idx, detail_start_x, line)

        self.stdscr.refresh()


    def display_full_logs(self, result):
        """
        Displays full logs in a scrollable view.

        Args:
            result (dict): The result containing full logs.
        """
        max_y, max_x = self.stdscr.getmaxyx()
        pad = curses.newpad(len(result['errors']) + 1, max_x - 4)

        for idx, error in enumerate(result['errors']):
            pad.addstr(idx, 0, error)

        pad_pos = 0
        while True:
            pad.refresh(pad_pos, 0, 2, 2, max_y - 3, max_x - 2)
            key = self.stdscr.getch()
            if key == curses.KEY_DOWN and pad_pos < len(result['errors']) - (max_y - 5):
                pad_pos += 1
            elif key == curses.KEY_UP and pad_pos > 0:
                pad_pos -= 1
            elif key in [ord('q'), ord('Q')]:
                break

        self.stdscr.clear()
        self.render(self.menu.get_selected_option())

    def display_operation_message(self, message):
        max_y, max_x = self.stdscr.getmaxyx()
        split_point = max_x // 3

        # Mevcut detay alanını temizle
        for y in range(3, max_y - 4):
            self.stdscr.addstr(y, split_point + 2, " " * (max_x - split_point - 4))

        # Mesajı detay alanında göster
        self.stdscr.addstr(3, split_point + 2, message)
        self.stdscr.refresh()

    def get_password(self, prompt):
        curses.echo()  # Karakterleri göster
        self.stdscr.addstr(self.window_height - 1, 0, prompt)
        password = self.stdscr.getstr().decode('utf-8')
        curses.noecho()  # Karakterleri gizle
        self.stdscr.addstr(self.window_height - 1, 0, " " * len(prompt))  # Prompt'u temizle
        return password


    def get_password_in_details(self, prompt):
        max_y, max_x = self.stdscr.getmaxyx()
        split_point = max_x // 3

        # Mevcut detay alanını temizle
        for y in range(3, max_y - 4):
            self.stdscr.addstr(y, split_point + 2, " " * (max_x - split_point - 4))

        # Prompt'u detay alanında göster
        self.stdscr.addstr(3, split_point + 2, prompt)
        self.stdscr.refresh()

        # Şifreyi al
        curses.echo()
        password = self.stdscr.getstr(4, split_point + 2, 30).decode('utf-8')
        curses.noecho()

        # Şifre alanını temizle
        self.stdscr.addstr(4, split_point + 2, " " * 30)
        self.stdscr.refresh()

        return password